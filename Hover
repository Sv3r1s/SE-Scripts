List<IMyGyro> gyros;
        List<IMyThrust> thrusterlist;
        IMyCockpit cockpit;
        float gyromult = 1;
        double desiredelevation = 10;
        double desirefvelocity = 0;
        double forwardaccel = 0;
        double currentfvelocity = 0;
        double oldcurrentfvelocity = 0;
        double Altitude = 0;
        double AltitudeNorm = 0;
        double x = 0;
        double h = 0;

        int mode = 0;

        //Координаты центра планеты
        int Px = -284464;
        int Py = -2434463;
        int Pz = 365536;
        Vector3D Planet, MyPos, AltVector;

        public Program()
        {
            cockpit = GridTerminalSystem.GetBlockWithName("Cockpit") as IMyCockpit;
            gyros = new List<IMyGyro>();
            GridTerminalSystem.GetBlocksOfType<IMyGyro>(gyros);
            thrusterlist = new List<IMyThrust>();
            GridTerminalSystem.GetBlocksOfType<IMyThrust>(thrusterlist);
        }

        public void Main(string argument)
        {


            //вкл/выкл
            if (argument == ("Start"))
            {
                Runtime.UpdateFrequency = UpdateFrequency.Update1;
                foreach (IMyGyro gyro in gyros)
                {
                    gyro.GyroOverride = true;
                }
                desirefvelocity = 0;
                x = 0;
            }
            else if (argument == ("Stop"))
            {
                Runtime.UpdateFrequency = UpdateFrequency.None;
                foreach (IMyGyro gyro in gyros)
                {
                    gyro.GyroOverride = false;
                }
            }
            else if (argument == ("HoverMode"))
            {
                mode = 0;
            }
            else if (argument == ("DrillMode"))
            {
                mode = 1;
                //Моя Позиция,центр планеты и высота
                MyPos = cockpit.GetPosition();
                Planet = new Vector3D(Px, Py, Pz);
                AltVector = MyPos - Planet;
                Altitude = AltVector.Length();
                double currentelevation = 0;
                cockpit.TryGetPlanetElevation(MyPlanetElevation.Surface, out currentelevation);
                h = Altitude - currentelevation;
            }
            else if (argument == ("Up"))
            {
                x = 0.001;
            }
            else if (argument == ("Down"))
            {
                x = -0.001;
            }

            if (mode == 0) HoverMode();
            if (mode == 1) DrillMode(h);

        }

        public void HoverMode()
        {
            //коэфф-ты для тяги
            float kV = 5;
            float kA = 10;

            //коэфф-ты для наклона
            float tkV = 0.2f;
            float tkA = 0.2f;

            //векторы гравитации и скорости
            Vector3D gravvector = cockpit.GetNaturalGravity();
            Vector3D gravvectornorm = Vector3D.Normalize(gravvector);
            Vector3D speedvector = cockpit.GetShipVelocities().LinearVelocity;

            desirefvelocity -= cockpit.MoveIndicator.Z / 5;
            //Текущая высота,вертикальная скорость и вес
            desiredelevation += cockpit.MoveIndicator.Y / 5;
            double currentelevation = 0;
            cockpit.TryGetPlanetElevation(MyPlanetElevation.Surface, out currentelevation);
            double mass = cockpit.CalculateShipMass().PhysicalMass;
            float vertvelocity = -(float)speedvector.Dot(gravvectornorm);
            float deltaelevation = (float)(desiredelevation - currentelevation);
            float weight = (float)gravvector.Length() * cockpit.CalculateShipMass().PhysicalMass;
            Vector3D forward = Vector3D.Normalize(Vector3D.Reflect(cockpit.WorldMatrix.Forward, gravvectornorm));

            //косинус угла наклона корабля относительно горизонта
            float tcos = (float)(cockpit.WorldMatrix.Down.Dot(gravvector));

            float maxthr = 0;
            foreach (IMyThrust thr in thrusterlist)
            {
                maxthr = thr.MaxEffectiveThrust * thrusterlist.Count;
            }


            double StopDis = (Math.Pow(vertvelocity,2) * mass) / (2 * weight);
            double StopDisTR = (Math.Pow(vertvelocity, 2) * mass) / (2 * (maxthr - weight));

            //Тяга
            float thrust = (weight * (deltaelevation * kV - vertvelocity) * kA) / tcos;

            if (deltaelevation > 10)
            {
                if (deltaelevation <= StopDis & vertvelocity > 0) thrust = 1;
                else thrust = maxthr;
            }
            if (deltaelevation < -1)
            {
                if (-deltaelevation <= StopDisTR & vertvelocity < 0) thrust = maxthr;
                else thrust = 1;
            }

            if (thrust <= 0)
            {
                thrust = 1;
            }


            gravvectornorm = Vector3D.Reflect(gravvectornorm, cockpit.WorldMatrix.Down);
            Vector3D speedvectornorm = Vector3D.Reject(speedvector, cockpit.WorldMatrix.Forward) / 10;
            if (speedvectornorm.Length() > 1)
            {
                speedvectornorm = Vector3D.Normalize(speedvectornorm);
            }

            //управление
            Vector3D forwardc = Vector3D.Normalize(Vector3D.Reflect(cockpit.WorldMatrix.Forward, gravvectornorm)) * cockpit.MoveIndicator.Z;
            Vector3D leftc = Vector3D.Normalize(Vector3D.Reflect(cockpit.WorldMatrix.Left, gravvectornorm)) * cockpit.RollIndicator;

            //управление скоростью
            currentfvelocity = speedvector.Dot(forward);
            forwardaccel = currentfvelocity - oldcurrentfvelocity;
            oldcurrentfvelocity = currentfvelocity;
            double velocitydelta = desirefvelocity - currentfvelocity;

            double velocityfactor = (velocitydelta * tkV - forwardaccel) * tkA;
            Vector3D tcorrector = -(forward * velocityfactor);

            Vector3D alignvector = Vector3D.Normalize(gravvectornorm + tcorrector + speedvectornorm / 2 + leftc / 1.2);

            //управление гироскопами
            float Pitch = (float)alignvector.Dot(cockpit.WorldMatrix.Backward);
            float Roll = (float)alignvector.Dot(cockpit.WorldMatrix.Left);
            float yaw = cockpit.MoveIndicator.X;
            foreach (IMyGyro gyro in gyros)
            {
                gyro.Yaw = yaw;
                gyro.Pitch = Pitch * gyromult;
                gyro.Roll = Roll * gyromult;
            }

            //управление движками
            foreach (IMyThrust thr in thrusterlist)
            {
                thr.ThrustOverride = thrust / thrusterlist.Count;
            }
            IMyTextSurface LCD = cockpit.GetSurface(0);
            LCD.WriteText("Elevation:" + desiredelevation + "\nSpeed:" + desirefvelocity + "\nAltitude:" + currentelevation + "\nStopDis" + StopDis + "\nDe: " + deltaelevation + "\nThr: " + thrust);
        }
        public void DrillMode(double h)
        {
            //коэфф-ты для тяги
            float kV = 5;
            float kA = 10;

            //коэфф-ты для наклона
            float tkV = 0.2f;
            float tkA = 0.2f;

            //векторы гравитации и скорости
            Vector3D gravvector = cockpit.GetNaturalGravity();
            Vector3D gravvectornorm = Vector3D.Normalize(gravvector);
            Vector3D speedvector = cockpit.GetShipVelocities().LinearVelocity;

            //Моя Позиция,центр планеты и высота
            MyPos = cockpit.GetPosition();
            Planet = new Vector3D(Px, Py, Pz);
            AltVector = MyPos - Planet;
            Altitude = AltVector.Length();
            AltitudeNorm = Altitude - h;

            //Текущая высота,вертикальная скорость и вес
            desiredelevation += cockpit.MoveIndicator.Y / 5;
            desiredelevation += x;
            float vertvelocity = -(float)speedvector.Dot(gravvectornorm);
            float deltaelevation = (float)(desiredelevation - AltitudeNorm);
            float weight = (float)gravvector.Length() * cockpit.CalculateShipMass().PhysicalMass;
            Vector3D forward = Vector3D.Normalize(Vector3D.Reflect(cockpit.WorldMatrix.Forward, gravvectornorm));

            //косинус угла наклона корабля относительно горизонта
            float tcos = (float)(cockpit.WorldMatrix.Down.Dot(gravvector));

            //Тяга
            float thrust = (weight * (deltaelevation * kV - vertvelocity) * kA) / tcos;
            if (thrust <= 0)
            {
                thrust = 1;
            }


            gravvectornorm = Vector3D.Reflect(gravvectornorm, cockpit.WorldMatrix.Down);
            Vector3D speedvectornorm = Vector3D.Reject(speedvector, cockpit.WorldMatrix.Forward) / 10;
            if (speedvectornorm.Length() > 1)
            {
                speedvectornorm = Vector3D.Normalize(speedvectornorm);
            }

            //управление
            Vector3D forwardc = Vector3D.Normalize(Vector3D.Reflect(cockpit.WorldMatrix.Forward, gravvectornorm)) * cockpit.MoveIndicator.Z;
            Vector3D leftc = Vector3D.Normalize(Vector3D.Reflect(cockpit.WorldMatrix.Left, gravvectornorm)) * cockpit.RollIndicator;

            //управление скоростью
            currentfvelocity = speedvector.Dot(forward);
            forwardaccel = currentfvelocity - oldcurrentfvelocity;
            oldcurrentfvelocity = currentfvelocity;
            double velocitydelta = (-cockpit.MoveIndicator.Z) - currentfvelocity;

            double velocityfactor = (velocitydelta * tkV - forwardaccel) * tkA;
            Vector3D tcorrector = -(forward * velocityfactor);

            Vector3D alignvector = Vector3D.Normalize(gravvectornorm + tcorrector + speedvectornorm / 2 + leftc / 1.2);

            //управление гироскопами
            float Pitch = (float)alignvector.Dot(cockpit.WorldMatrix.Backward);
            float Roll = (float)alignvector.Dot(cockpit.WorldMatrix.Left);
            float yaw = cockpit.MoveIndicator.X;
            foreach (IMyGyro gyro in gyros)
            {
                gyro.Yaw = yaw;
                gyro.Pitch = Pitch * gyromult;
                gyro.Roll = Roll * gyromult;
            }

            //управление движками
            foreach (IMyThrust thr in thrusterlist)
            {
                thr.ThrustOverride = thrust / thrusterlist.Count;
            }
            IMyTextSurface LCD = cockpit.GetSurface(0);
            LCD.WriteText("Elevation:" + desiredelevation + "\nSpeed:" + (-cockpit.MoveIndicator.Z) + "\nAltitude:" + AltitudeNorm);
        }
